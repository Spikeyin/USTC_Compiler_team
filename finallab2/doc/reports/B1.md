## B1 支配树

#### B1-1

我们可以假定存在一条从入口节点（ENTRY）到 x 的路径 P₁，该路径尚未经过 y。若不存在这样的路径，我们可以通过逆向追溯并调整路径直到满足此条件。

下证明一个重要性质：从 x 出发到达 b 的任意路径，在到达 b 之前必然会经过 y。
通过反证法：
假设存在一条从 x 到 b 的路径 P₂，该路径未经过 y
那么路径 P₁ 与 P₂ 的组合将构成一条从入口到 b 且不经过 y 的路径
这与 y 支配 b 的前提矛盾

对于任何从入口到 b 的路径：
必然会经过 x 和 y
在最后一次到达 b 之前，最后经过的必定是 y（而非 x）

基于上述特征：
必存在一条从 y 出发到达 b 且未经过 x 的路径 P₃
可以证明：所有从入口到 y 的路径都必须经过 x
若存在一条不经过 x 的路径 P₄
则 P₄ 与 P₃ 的组合将形成一条不经过 x 就到达 b 的路径
这与 x 支配 b 的条件矛盾

因此，所有到达 y 的路径都必须经过 x，即 x 支配 y。
#### B1-2
内层循环不一定要以后序遍历的逆序进行，但使用后序遍历的逆序会提高性能。

从算法正确性的角度来看，任何遍历顺序都能最终收敛到正确结果
这是因为迭代算法的本质是不断应用支配关系的定义，直到没有节点的支配者集合发生变化
每次迭代都会使支配者集合单调递减，最终必然收敛

使用后序遍历的逆序有以下优势：
后序遍历的逆序意味着先处理支配树中更接近根节点的节点
这种顺序使得支配信息能更快地从入口节点传播到其他节点
通常可以减少迭代次数，加快收敛速度
#### B1-3
在这个算法中，内层循环必须按照后序遍历的逆序进行。

这个算法不仅计算支配关系，还直接构建支配树，它使用了 semi（半支配点）和 idom（直接支配点）的概念，算法要求在计算节点 n 的半支配点时，所有在 n 的后序编号之后的节点的半支配点都已经计算完成。

对于节点 n，计算其半支配点需要：
考虑所有能到达 n 的前驱节点
通过这些前驱节点的祖先来更新 n 的半支配点
如果不按后序遍历的逆序处理，某些必需的半支配信息可能尚未计算出来，导致结果错误
#### B1-4
1. intersect 的作用
intersect 函数用于找到两个节点在支配树路径上的最低公共祖先（从半支配点的角度），它在计算节点 v 的直接支配点时，通过比较从 v 到其半支配点路径上的所有节点的半支配点，找到半支配点编号最小的节点

2. 不能改成大于号，原因如下：

后序编号越小，表示节点在后序遍历中越早被访问
半支配点的编号越小，表示该节点越接近树的根节点
算法需要找到最小的半支配点编号，因为这代表着最接近根节点的支配点

使用小于号确保了算法会向上遍历直到找到具有最小半支配点编号的节点
如果改成大于号，会导致算法向下遍历，无法找到正确的最低公共祖先
#### B1-5
1. 时间（效率）方面：
采用后序遍历的逆序处理基本块，加快了信息传播速度
通过支配树结构查找共同祖先，避免了传统集合运算的开销
支配关系的查询效率与哈希表遍历相当，但实现更简单直观
2. 空间方面：内存利用率高
采用树形结构存储支配关系，避免了为每个基本块单独维护支配集合
所有节点的支配信息统一存储在一个数据结构中，显著降低了空间复杂度
数据组织更加紧凑，提高了缓存利用效率

#### B1-6
代码中确定 EXIT 节点相关代码：
```c
for(auto bb:f->get_basic_blocks()){
    auto terminate_instr = bb->get_terminator();
    if(terminate_instr->is_ret()){
        exit_block = bb;
        break;
    }
}
```
即检查这个基本块的最后一条语句是否是 `ret` 语句；



为什么不能用最后一个基本块：
最后一个基本块的位置是由基本块的存储顺序决定的，这是任意的
最后一个基本块可能不是实际的程序出口
可能存在以下情况：
```
  BB1: 
    if (condition) goto BB2
    else goto BB4
  BB2:
    return x
  BB3:
    ...
  BB4: (最后一个基本块)
    goto BB3
```
这里最后一个基本块 BB4 显然不是真正的程序出口