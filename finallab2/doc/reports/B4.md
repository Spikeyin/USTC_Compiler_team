## 优化

#### B4-1

​	设计思路：   我们用 set 来区分两个表达式是否相等， 所以我们优先在 cmp_expr 中定义两个表达式a 小于 表达式b 的情况。 我们认为加， 乘的两个操作数可以调换位置。 然后按 \{ OpID, 操作数类型, 数值大小(常量) or 指针大小(变量) \} 按字典序比较两个表达式的大小， 对于操作符为加、乘的表达式， 我们做归一化， 总是让字典序计算下来较小的表达式在操作符左侧。

​	我们有了cmp_expr来判断表达式 a < b 是否成立， 就可以用 ! (a < b) $$ ! (b < a) 来判断两个表达式是否相等。如果在set中， 就直接用set 不重复元素的特性来判断相等。 

​	然后， 我们先计算每一个基本块的 gen ， 因为是SSA， 每个变量只会被赋值一次， 所以我们不需要计算kill， kill集永远为空。 我们依次判断每个语句是否是表达式， 如果是， 将其加入bb_gen中即可。

​	然后， 我们计算 IN, OUT， 遍历到OUT集合不变为止， 遍历的顺序无所谓， 最后都会得到同一个结果。 

​	然后， 我们依次替换表达式并且消除死代码。 除了bb_IN 用于块间的公共表达式记录， 我们用 bb_cur 实现块内的公共表达式记录。 对于每一条指令， 我们先判断它是否是表达式。如果是， 我们判断它是否出现在 bb_IN 中， 如果出现，我们就向前寻找它第一次定义的位置， 也就是出现在某一基本块的gen 中 但是没有出现在 IN 中的对应的指令， 在向前寻找的过程中， 如果某一个基本块的表达式来源于两个不同的基本块的 OUT 取出的交集里， 我们需要发射 $\phi$ 指令， 从两条路径中选出对应的公共子表达式。 否则， 如果它出现在 bb_cur 中， 说明它在当前基本块前面出现过， 我们直接执行替换即可。 如果都没有出现， 那么说明它是新遇到的表达式， 我们将它加入bb_cur 中， 然后继续遍历下一个指令。

​	为了防止引发使用空指针导致的段错误， 我们将死代码记录并到最后一起删除。 



#### B4-2

​	void 指令没有返回值， 可能难以进行公共表达式的优化， alloca指令每次申请新的地址空间， 也难以进行优化。

​	对于 phi 指令， 即使每一个选择项都相同， 在实际运行时选择的数据可能也不相同， 较难进行优化。 

​	而对于 load 指令， 如果读取的地址是相同的， 应该是可以进行公共表达式的替换的。

​	对于 call 指令， 如果调用同一个函数， 同样的参数， 并且函数中没有静态变量的情况下返回值也应该是相同的。 

​	对于cmp 和 fcmp， 应该可以认为它们是普通的表达式， 依次比较操作符， 操作数可以判断两个是否相同， 也应该可以进行公共表达式的替换。



#### B4-3
##### 所设计的检查内容
1. **BB pred and succ check**：
   设计该检查内容的理由：在`LiveVar`遍过程中，由于一个基本块会访问它的所有后继块，如果代码不正确可能会修改它们之间的`pred-succ`关系，所以对这些关系进行一次检查。

   具体方法：对每个函数中的每一个块，检查其所有前驱基本块的后继中是否存在它本身，再检查其后继基本块的前驱中是否存在它本身：

2. **last inst of BB check**
   设计该检查内容的理由：因为这是由基本块的定义保证的，在进行代码优化时，如果处理不当可能会对某些指令造成不当的删除，其中就包括基本块结束的跳转指令和返回指令，所以需要检查一遍。

   具体方法：对每个函数的每个基本块，检查其最后一条指令是不是`isTerminator`即可。

3. **use-def chain check**
   设计该检查内容的理由：在`Mem2Reg`遍中有对`use-def chain`的访问和使用，所以检查一遍是需要的。

   具体方法：遍历基本块内`use`是否在`use_list`中出现即可：

4. **def before use check**。
   设计该检查内容的理由：变量不定义就引用自然是不合理的，所以需要检查在优化之后，是否出现了这种错误。

   具体方法：先得到所有的变量定值集合，然后访问所有指令，看出现的变量是否在集合中有记录。
##### 检查器插入的代码位置
在`main.cpp`中，加入`check pass`
具体如下：
```c++
if(optimize){
    IR::PassMgr passmgr(m);
    passmgr.addPass<IR::DominateTree>();
    passmgr.addPass<IR::Mem2Reg>();
    if(optimize_all){
        passmgr.addPass<IR::LiveVar>();
        passmgr.addPass<IR::ComSubExprEli>();
        passmgr.addPass<IR::Check>();    // check pass
        //  ...
    }
    else {
        if(lv){
            passmgr.addPass<IR::LiveVar>();
            passmgr.addPass<IR::Check>();// check pass
        }
        if(cse){
            passmgr.addPass<IR::ComSubExprEli>();
            passmgr.addPass<IR::Check>();// check pass
        }
        else{
            passmgr.addPass<IR::Check>();// check pass
        }
        //  ...
    }
    passmgr.execute();
    m->set_print_name();
}
```
这么添加是因为需要在每次优化后，都需要进行一次`Check Pass`，尽管只有`-O`参数，`else`部分增加的`Check`也能保证在进行支配树分析和`Mem2Reg`后也会进行`Check`。